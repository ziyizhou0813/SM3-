# 基于SIMD优化SM3算法

## SIMD优化思路

SM3算法是一种分组密码算法。其分组长度为128bit，以字（32位）为单位进行加密运算。通过观察整个SM3算法，主要分为消息填充、消息扩展和压缩函数三个部分。

### 消息填充

SM3对消息的处理是分组进行的，每组长度64字节，如果消息的长度不是64字节的整数倍，即最后一个分组的长度不是64字节，就需要对最后一个分组进行填充。
对于消息填充，我们只需要对其进行简单的优化尝试，例如对于循环展开和基于流水线的优化。
在本次project中在消息填充最多尝试的是循环展开，分成不同的步长，发现对于时间上没有明显的优化，猜测可能由于数据大小不够大体现出不来，又或者是电脑的寄存器和cpu核数并没有完全匹配，使得性能提升不大。

### 消息扩展

消息扩展部分是本次SM3算法优化中主要研究的方向。我们发现在消息扩展中将512bit消息分为16个32bit的字进行加密计算。
这里我们将字保存在unsigned int类型W数组中，公式如下：

$P_1(X) = X \oplus (X \lll 15)  \oplus (X \lll 23)$

$W_j=P_1(W_{j-16} \oplus W_{j-9} \oplus (W_{j-16} \lll 15)) \oplus (W_{j-13} \lll 7) \oplus W_{j-6}$

$W_j'  = W_j \oplus W_{j+4}$

通过这16个字可生成下16个字，最终扩展生成132个字。所以我们可以将生成16个字看为1轮，使用SIMD中__m128i存储方式，可以将4个字存储在一个寄存器中，一次同时进行4个字的生成计算，可以大大优化性能。大体流程可以从下图中看出

![This is an image](https://github.com/ziyizhou0813/SM3-optimization/blob/sm3-v2/sm3%20-v2/%E6%B6%88%E6%81%AF%E6%89%A9%E5%B1%95%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B.jpg)

上图右边就是把消息放进寄存器，然后做消息扩展，和上图左边一次计算出一个字$W_j$相比，右边一次可以计算出3个字$W_{j}$,$W_{j+1}$,$W_{j+2}$ 。之所以不是一次计算出4个字 ，是因为$W_{j+3}$的计算需要用到 $W_{j}$，但$W_{j}$又是扩展出来的，此时$W_{j}$还未算出。在具体的实现中，我是先等$W_{j}$,$W_{j+1}$,$W_{j+2}$计算完成，再用上图左边的方法计算$W_{j+3}$。

### 压缩函数

对于压缩函数这个部分，并没有采取有效的优化。因为压缩函数属于一种线性的计算，本轮的处理好的数据会作用到下一轮之中，若要采用并行的优化方法是不能直接实现的，所以在这并没有深度研究下去。

## 结果对比

最后我们将优化前和优化后的性能测试进行对比，如下图所示：

优化前：

![This is an image](https://github.com/ziyizhou0813/SM3-optimization/blob/sm3-v2/%E4%BC%98%E5%8C%96%E5%89%8D.png)

优化后：

![This is an image](https://github.com/ziyizhou0813/SM3-optimization/blob/sm3-v2/%E4%BC%98%E5%8C%96%E5%90%8E.png)

我们发现在基于SIMD优化后的消息扩展的SM3算法快了0.1秒左右。

因为这是加密一组的结果，若对于更大的数据，这0.1的优化则会带来更好性能提升。

